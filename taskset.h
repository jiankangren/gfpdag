#ifndef _TASKSET_H_
#define _TASKSET_H_

#include <vector>
#include "task.h"
#include "common.h"

using namespace std;

class TaskSet {
 public:
	TaskSet(double desired_util, unsigned int num_procs, 
			unsigned long wmin, unsigned long wmax, double p, double beta);

	TaskSet(vector<double> utils, unsigned int num_procs, unsigned long wmin, 
			unsigned long wmax, double p);

	bool is_schedulable();

	// Response-time analysis for different priority assignment
	bool rta_dm();
	bool rta_ws();
	bool rta_ls();

	// Slack-based iterative test for different priority assignment
	bool slacktest_dm();
	bool slacktest_ws();
	bool slacktest_ls();

	// Schedulability test by Melani et al.
	bool melani_dm();
	bool melani_ws();
	bool melani_ls();

	void print_taskset() const;

 private:
	// Response-time analysis schedulability test
	bool rta(RtaType type);
	
	// Slack-based iterative schedulability test
	bool slacktest();

	// Calculate response-time bound
	unsigned long calc_rt_bound(unsigned int i, RtaType type);

	// Sort the tasks in Deadline Monotonic order
	static bool comp_dm(Task i, Task j);
	void sort_dm();
	
	// Sort the tasks in Workload Slack order
	static bool comp_ws(Task i, Task j);
	void sort_ws();

	// Sort the tasks in Critical-path Length Slack order
	static bool comp_ls(Task i, Task j);
	void sort_ls();

	// Compute total workload generated by an interfering task
	unsigned long calc_workload(unsigned int k, unsigned long len, RtaType type);
	unsigned long calc_workload_ours(unsigned int k, unsigned long len);
	unsigned long calc_workload_melani(unsigned int k, unsigned long len);
	long slack_compute(unsigned int i);
	unsigned long calc_workload_slack(unsigned int k, unsigned long len);

	// Compute body workload
	unsigned long calc_body_workload(unsigned int k, unsigned long len);
	unsigned long calc_body_workload_slack(unsigned int k, unsigned long len);

	// Compute carry-in and carry-out workloads
	unsigned long calc_carryin_workload(unsigned int k, unsigned long len);
	unsigned long calc_carryout_workload(unsigned int k, unsigned long len);
	unsigned long calc_ci_co_bound(Task &task, unsigned long len, WorkloadType type);

	// Maximize carry-in or carry-out workload with 
	// indirect call to SCIP (old code) and direct call to SCIP.
	unsigned long maximize_indirect_call_scip(Task &task, unsigned long len, WorkloadType type);
	unsigned long maximize_direct_call_scip(Task &task, unsigned long len, WorkloadType type);
	
	unsigned long maximize_carryin_scip(Task &task, unsigned long len);
	unsigned long maximize_carryin_fonseca(Task &task, unsigned long len);

 private:
	vector<Task> tasks;
	unsigned int m;
	unsigned int n;
};

#endif
